t <- turtle(startpos, initdir, initlen)
if (initlen > lenlimit){
dir <- -dir
fern_2(t, initdir, initlen * 0.87, lenlimit, dir)   # Go straight up
fern_2(t, initdir + (45 * dir), initlen * 0.38, lenlimit,-dir)     # Furl
}
}
plot(-50:50, -50:50, type="n", xaxt='n', yaxt='n', ann=FALSE, bty='n')
fern_2(c(0,-50), 90, 11, 0.1)
fern_2 <- function(startpos=c(0,-50), initdir=90, initlen=13, lenlimit=0.1, dir=-1){
t <- turtle(startpos, initdir, initlen)
if (initlen > lenlimit){
dir <- -dir
fern_2(t, initdir, initlen * 0.87, lenlimit, dir)   # Go straight up
fern_2(t, initdir + (45 * dir), initlen * 0.38, lenlimit,-dir)     # Furl
}
}
plot(-50:50, -50:50, type="n", xaxt='n', yaxt='n', ann=FALSE, bty='n')
fern_2(c(0,-50), 90, 11, 0.01)
fern_2 <- function(startpos=c(0,-50), initdir=90, initlen=13, lenlimit=0.1, dir=-1){
t <- turtle(startpos, initdir, initlen)
if (initlen > lenlimit){
dir <- -dir
fern_2(t, initdir, initlen * 0.87, lenlimit, dir)   # Go straight up
fern_2(t, initdir + (45 * dir), initlen * 0.38, lenlimit,-dir)     # Furl
}
}
plot(-50:50, -50:50, type="n", xaxt='n', yaxt='n', ann=FALSE, bty='n')
fern_2(c(0,-50), 90, 11, 0.1)
l=function(v,d,a,i){if(a>.001){w=v+a*c(cos(d),sin(d));segments(v[1],w[1],v[2],w[2]);l(w,d+i,a*.38,i);l(w,d,a*.87,-i)}};plot(0,0,cex=0);l(c(0,0),1.57,.1,.78)
l=function(v,d,a,i){if(a>.001){w=v+a*c(cos(d),sin(d));segments(v[1],v[2],w[1],w[2]);l(w,d+i,a*.38,i);l(w,d,a*.87,-i)}};plot(0,0,cex=0);l(c(0,0),1.57,.1,.78)
l=function(v,d,a,i){if(a>.001){w=v+a*c(cos(d),sin(d));segments(c(v,w));l(w,d+i,a*.38,i);l(w,d,a*.87,-i)}};plot(0,0,cex=0);l(c(0,0),1.57,.1,.78)
a,b = 1,2
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggpubr)
library(segmented)
setwd("~/Work/CMEEProject/Code")
dahriel_comm_data <- read.csv("../Data/d1718_SI.csv")
dahriel_comm_ledg <- read.csv("../Data/dahriel_community_legend.csv")
unique(dahriel_comm_data$Abrev_species)
dahriel_comm_data %>%
group_by(Abrev_species) %>%
summarise(count = n_distinct(Spider_Label))
dahriel_comm_data <- dahriel_comm_data %>% rowwise() %>% mutate(
Mean_diameter = mean(c(Vertical_diameter.mm, Horizontal_diameter.mm))
)
dahriel_comm_data <- dahriel_comm_data %>% mutate(
MW_per_CA = Mesh_width.mm / Capture_area_surface.mm2
)
dahriel_comm_data = as.data.frame(dahriel_comm_data)
head(dahriel_comm_data)
test_sub <- dahriel_comm_data
test_sub <- filter(test_sub, test_sub$Cephalothorax_size != 0)
mwvca.plot <- ggplot(data = test_sub, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm))
# mwvca.plot <- mwvca.plot + geom_point(alpha = 0.25, pch=20)
mwvca.plot <- mwvca.plot + geom_smooth(method="loess", aes(colour = "black"), se=F, size = 0.5)
# mwvca.plot <- mwvca.plot + geom_smooth(method="glm", colour = "darkblue", se=F, size = 1)
mwvca.plot <- mwvca.plot + labs(title = "Mesh Width + LOESS", x = expression("Capture Area "(mm^2)), y = "Mesh Width (mm)") + scale_x_continuous(limits = c(0, 180000), breaks = scales::pretty_breaks(n = 10))
mwvca.plot <- mwvca.plot + theme_bw() + theme(plot.title = element_text(size=10))
# mwvca.plot <- mwvca.plot + theme(legend.position="none")
print(mwvca.plot + geom_smooth(method="glm", colour = "darkblue", se=F, size = 1))
mwvca.full <- glm(Mesh_width.mm ~ Capture_area_surface.mm2, data = test_sub)
summary(mwvca.full)
mwvca.seg <- segmented(mwvca.full,
seg.z = ~ Capture_area_surface.mm2,
psi = list(Capture_area_surface.mm2 = c(3000)))
summary(mwvca.seg)
cat("\n\n---- Breakpoints ----\n")
mwvca.seg$psi
cat("\n\n---- Breakpoint Sig ----\n")
davies.test(mwvca.full, seg.Z = ~ Capture_area_surface.mm2)
cat("\n\n---- Slope ----\n\n")
slope(mwvca.seg)
cat("\n\n---- CIs ----\n\n")
confint.segmented(mwvca.seg)
mwvca.fitted <- fitted(mwvca.seg)
mwvca.model <- data.frame(Capture_area_surface.mm2 = test_sub$Capture_area_surface.mm2, Mesh_width.mm = mwvca.fitted)
ggplot(mwvca.model, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm)) + geom_line()
mwvca.lines <- mwvca.seg$psi[, 2]
mwvca.plot <- mwvca.plot +
geom_line(data = mwvca.model, aes(x = log(Capture_area_surface.mm2), y = log(Mesh_width.mm), colour = "tomato"), size = 1) +
geom_vline(xintercept = mwvca.lines, linetype = "dashed") +
scale_colour_manual(name = 'Line',
values =c('black'='black','tomato'='tomato'), labels = c('LOESS','Segmented'))
print(mwvca.plot + scale_x_continuous(labels = scales::scientific) + theme())
mwvca.lines <- mwvca.seg$psi[, 2]
mwvca.plot <- mwvca.plot +
geom_line(data = mwvca.model, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm, colour = "tomato"), size = 1) +
geom_vline(xintercept = mwvca.lines, linetype = "dashed") +
scale_colour_manual(name = 'Line',
values =c('black'='black','tomato'='tomato'), labels = c('LOESS','Segmented'))
print(mwvca.plot + scale_x_continuous(labels = scales::scientific) + theme())
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggpubr)
library(segmented)
setwd("~/Work/CMEEProject/Code")
dahriel_comm_data <- read.csv("../Data/d1718_SI.csv")
dahriel_comm_ledg <- read.csv("../Data/dahriel_community_legend.csv")
unique(dahriel_comm_data$Abrev_species)
dahriel_comm_data %>%
group_by(Abrev_species) %>%
summarise(count = n_distinct(Spider_Label))
dahriel_comm_data <- dahriel_comm_data %>% rowwise() %>% mutate(
Mean_diameter = mean(c(Vertical_diameter.mm, Horizontal_diameter.mm))
)
dahriel_comm_data <- dahriel_comm_data %>% mutate(
MW_per_CA = Mesh_width.mm / Capture_area_surface.mm2
)
dahriel_comm_data = as.data.frame(dahriel_comm_data)
head(dahriel_comm_data)
test_sub <- dahriel_comm_data
test_sub <- filter(test_sub, test_sub$Cephalothorax_size != 0)
mwvca.plot <- ggplot(data = test_sub, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm))
# mwvca.plot <- mwvca.plot + geom_point(alpha = 0.25, pch=20)
mwvca.plot <- mwvca.plot + geom_smooth(method="loess", aes(colour = "black"), se=F, size = 0.5)
# mwvca.plot <- mwvca.plot + geom_smooth(method="glm", colour = "darkblue", se=F, size = 1)
mwvca.plot <- mwvca.plot + labs(title = "Mesh Width + LOESS", x = expression("Capture Area "(mm^2)), y = "Mesh Width (mm)") + scale_x_continuous(limits = c(0, 180000), breaks = scales::pretty_breaks(n = 10))
mwvca.plot <- mwvca.plot + theme_bw() + theme(plot.title = element_text(size=10))
# mwvca.plot <- mwvca.plot + theme(legend.position="none")
print(mwvca.plot + geom_smooth(method="glm", colour = "darkblue", se=F, size = 1))
mwvca.full <- glm(Mesh_width.mm ~ Capture_area_surface.mm2, data = test_sub)
summary(mwvca.full)
mwvca.seg <- segmented(mwvca.full,
seg.z = ~ Capture_area_surface.mm2,
psi = list(Capture_area_surface.mm2 = c(3000)))
summary(mwvca.seg)
cat("\n\n---- Breakpoints ----\n")
mwvca.seg$psi
cat("\n\n---- Breakpoint Sig ----\n")
davies.test(mwvca.full, seg.Z = ~ Capture_area_surface.mm2)
cat("\n\n---- Slope ----\n\n")
slope(mwvca.seg)
cat("\n\n---- CIs ----\n\n")
confint.segmented(mwvca.seg)
mwvca.fitted <- fitted(mwvca.seg)
mwvca.model <- data.frame(Capture_area_surface.mm2 = test_sub$Capture_area_surface.mm2, Mesh_width.mm = mwvca.fitted)
ggplot(mwvca.model, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm)) + geom_line()
mwvca.lines <- mwvca.seg$psi[, 2]
mwvca.plot <- mwvca.plot +
geom_line(data = mwvca.model, aes(x = Capture_area_surface.mm2, y = Mesh_width.mm, colour = "tomato"), size = 1) +
geom_vline(xintercept = mwvca.lines, linetype = "dashed") +
scale_colour_manual(name = 'Line',
values =c('black'='black','tomato'='tomato'), labels = c('LOESS','Segmented'))
print(mwvca.plot + scale_x_continuous(labels = scales::scientific) + theme())
subsetted <- subset(test_sub, Capture_area_surface.mm2 > mwvca.lines)
median(subsetted$Mesh_width.mm)
print(ggplot(data = subsetted, aes(x = Mesh_width.mm)) + geom_density() + geom_vline(xintercept = median(subsetted$Mesh_width.mm)))
generate = TRUE
generate_incomplete = TRUE
if (generate) {
date <- seq.Date(as.Date('2019/03/08'), as.Date('2019/08/08'), 'day')
date_length <- length(date)
starting_reading <- 27505
increment <- 30
measurement_seq <- seq(0, date_length - 1)
measurement <- measurement_seq * increment
measurement <- measurement + starting_reading
flucs <- as.integer(rnorm(date_length, 0, 5))
measurement <- measurement + flucs
measurement[1] <- starting_reading
interpolated <- as.logical(rep(NA, date_length))
if (generate_incomplete) {
measurement[unique(as.integer(runif(as.integer(date_length/10), 1, date_length)))] <- NA
}
readings <- data.frame(date, measurement, interpolated)
} else {
# Import CSV
quit()
}
interpolation_main <- function(df) {
# Take a df of readings and return an equivalent with nearest-neighbour interpolation performed on the measurements where possible.
if (all(is.na(df$measurement))) {
warning('Error in tailing NA removal: No data in measurement column!')
return(df)
}
working_df <- df
# Remove ending dates by removing iteratively until we hit a good value.
while (TRUE) {
if (is.na(working_df$measurement[nrow(working_df)])) {
working_df <- working_df[-c(nrow(working_df)),]
} else {
break
}
}
# Add back ending NAs when exporting
if (nrow(working_df) < nrow(df)){
rowdiff <- nrow(df) - nrow(working_df)
# Generate enough continuous dates, and make into df with NAs in other columns
end_dates <- seq.Date(max(working_df$date) + 1, by = 'day', length.out = rowdiff)
end_rows <- data.frame(end_dates, rep(NA, rowdiff), rep(NA, rowdiff))
names(end_rows) <- c('date', 'measurement', 'interpolated')
print(end_rows)
# Bind to working_df
working_df <- rbind(working_df, end_rows)
}
return(working_df)
}
seq(1,10)
seq(1,10)[1]
seq(1,10)[2]
seq(1,10)[10]
seq(1,10)[11]
!TRUE
test = TRUE
!test
test = FALSE
test2 = TRUE
test & test2
test = TRUE
test & test2
test <- c()
test <- as.vector(list())
test <- c()
test <- c(test, c(1,2))
test <- as.vector(list())
test <- c(test, c(1,2))
test <- as.vector(list())
test <- test.append(c(1,2))
test <- list.append(c(1,2))
floor(1.5)
ceiling(1.5)
install.packages("rlist")
library(rlist)
test <- vector('list', 10)
test[[1]] <- "hello"
test
list.clean(test)
test[[9]] <- "hello"
list.clean(test)
test
interpolation_runfinder <- function(v){
# Find runs of NAs in *a vector* and returns a list of vectors defining these runs by index in the following form:
# c(c(start1, end1), c(start2, end2), ...)
# If a run is of length one, end == start
# Note: this function assumes that v does NOT end in an NA (this should have been stripped prior to usage)
working_start <- 0
working_end <- 0
working_list <- vector('list', ceiling(length(v)/2))   # preallocate list to max possible size (length of v / 2)
working_list_counter <- 1
in_run <- FALSE
for (i in 1:length(v)) {
if (is.na(v[i])) {
# If value is NA
if (in_run) {
# If in run, just ignore for now
next
} else {
# If not in run, index is the start of a new run
working_start <- i
in_run <- TRUE
}
} else {
# If value is not NA
if (in_run) {
# If in run, set the previous index to be the endpoint, add the new vector to the working_list and reset working variables
working_end <- i - 1
working_list[[working_list_counter]] <- c(working_start, working_end)
working_list_counter <- working_list_counter + 1
in_run <- FALSE
} else {
# If not in run, just ignore
next
}
}
}
# Remove empty vars from list
working_list <- list.clean(working_list)
return(working_list)
}
interpolation_runfinder(c(1,2,3,NA,4,5))
interpolation_runfinder(c(1,2,3,NA,5,6))
interpolation_runfinder(c(1,2,3,NA,5,NA))
interpolation_runfinder(c(1,2,NA,NA,5,6))
interpolation_runfinder(c(1,2,NA,NA,NA,6))
interpolation_runfinder(c(1,NA,NA,NA,NA,6))
interpolation_runfinder(c(NA,NA,NA,NA,NA,6))
interpolation_runfinder <- function(v){
# Find runs of NAs in *a vector* and returns a list of vectors defining these runs by index in the following form:
# c(c(start1, end1), c(start2, end2), ...)
# If a run is of length one, end == start
# Note: this function assumes that v does NOT end in an NA (this should have been stripped prior to usage)
working_start <- NA
working_end <- NA
working_list <- vector('list', ceiling(length(v)/2))   # preallocate list to max possible size (length of v / 2)
working_list_counter <- 1
in_run <- FALSE
for (i in 1:length(v)) {
if (is.na(v[i])) {
# If value is NA
if (in_run) {
# If in run, just ignore for now
next
} else {
# If not in run, index is the start of a new run
working_start <- i
in_run <- TRUE
}
} else {
# If value is not NA
if (in_run) {
# If in run, set the previous index to be the endpoint, add the new vector to the working_list and reset working variables
working_end <- i - 1
working_list[[working_list_counter]] <- c(working_start, working_end)
working_start <- NA
working_end <- NA
working_list_counter <- working_list_counter + 1
in_run <- FALSE
} else {
# If not in run, just ignore
next
}
}
}
# Remove empty vars from list
working_list <- list.clean(working_list)
return(working_list)
}
interpolation_runfinder(c(NA,NA,NA,NA,NA,6))
interpolation_runfinder(c(NA,NA,3,NA,NA,6))
interpolation_runfinder(c(NA,NA,3,NA,NA,6))[1]
interpolation_runfinder(c(NA,NA,3,NA,NA,6))[[1]]
for (x in interpolation_runfinder(c(NA,NA,3,NA,NA,6))){
print(x)
}
for (x in interpolation_runfinder(c(NA,NA,3,NA,NA,6))){
print(x[1])
}
NA_runfinder <- function(v){
# Find runs of NAs in *a vector* and returns a list of vectors defining these runs by index in the following form:
# c(c(start1, end1), c(start2, end2), ...)
# If a run is of length one, end == start
# Note: this function assumes that v does NOT end in an NA (this should have been stripped prior to usage)
working_start <- NA
working_end <- NA
working_list <- vector('list', ceiling(length(v)/2))   # preallocate list to max possible size (length of v / 2)
working_list_counter <- 1
in_run <- FALSE
for (i in 1:length(v)) {
if (is.na(v[i])) {
# If value is NA
if (in_run) {
# If in run, just ignore for now
next
} else {
# If not in run, index is the start of a new run
working_start <- i
in_run <- TRUE
}
} else {
# If value is not NA
if (in_run) {
# If in run, set the previous index to be the endpoint, add the new vector to the working_list and reset working variables
working_end <- i - 1
working_list[[working_list_counter]] <- c(working_start, working_end)
working_start <- NA
working_end <- NA
working_list_counter <- working_list_counter + 1
in_run <- FALSE
} else {
# If not in run, just ignore
next
}
}
}
# Remove empty vars from list
working_list <- list.clean(working_list)
return(working_list)
}
test2
test = 2
isTRUE(test)
interpolation_root <- function(start, end, l){
difference <- end - start
stepval <- difference / (l + 1)
run_replacement <- rep(start, l)
additive_steps <- seq(1, l)
additive_steps <- additive_steps * stepval
run_replacement <- run_replacement + additive_steps
return(run_replacement)
}
interpolation_root(1,5,3)
interpolation_root(1,3,1)
interpolation_actor <- function(v, index_v, base_start = NA){
# Take a vector of measurements and a vector of NA run indices
# Interpolate runs of these values from the direct nearest neighbours
for (x in index_v) {
run_l <- x[2] - x[1] + 1
start_value <- 0
end_value <- 0
if (x[1] == 1) {
# If run starts at index 1, use base start as starting value, or assume no change at start if base_start is not provided
if (is.na(base_start)) {
start_value <- v[x[2] + 1]
end_value <- v[x[2] + 1]
} else {
start_value <- base_start
end_value <- v[x[2] + 1]
}
} else {
# Normal interpolation setup
start_value <- v[x[1] - 1]  # Get value before start of run
end_value <- v[x[2] + 1]    # Get value after end of run
}
# Interpolate values in run
run <- interpolation_root(start_value, end_value, run_l)
# Replace NA run with new values
v <- replace(v, x[1]:x[2], run)
}
return(v)
}
test1 <- c(5,8,9,NA,NA,15,19)
NA_runfinder(test1)
test2 <- NA_runfinder(test1)
interpolation_actor(test1, test2)
test1 <- c(5,8,9,NA,NA,NA,19)
test2 <- NA_runfinder(test1)
interpolation_actor(test1, test2)
interpolation_root <- function(start, end, l){
difference <- end - start
stepval <- difference / (l + 1)
run_replacement <- rep(start, l)
additive_steps <- seq(1, l)
additive_steps <- additive_steps * stepval
run_replacement <- run_replacement + additive_steps
run_replacement <- as.integer(run_replacement)
return(run_replacement)
}
interpolation_actor(test1, test2)
test1 <- c(NA,8,9,NA,NA,NA,19)
test2 <- NA_runfinder(test1)
interpolation_actor(test1, test2)
interpolation_actor(test1, test2, 6)
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
setwd("~/Coding/BarnMeter/Code")
# Import CSV
readings <- read.csv('../Data/readings.csv')
readings$date <- as.Date(readings$date, format = "%d/%m/%Y")
date <- seq.Date(as.Date('2019/03/08'), as.Date('2019/08/08'), 'day')
date_length <- length(date)
starting_reading <- 27505
increment <- 30
measurement_seq <- seq(0, date_length - 1)
measurement <- measurement_seq * increment
measurement <- measurement + starting_reading
flucs <- as.integer(rnorm(date_length, 0, 5))
measurement <- measurement + flucs
measurement[1] <- starting_reading
interpolated <- as.logical(rep(NA, date_length))
if (generate_incomplete) {
measurement[unique(as.integer(runif(as.integer(date_length/10), 1, date_length)))] <- NA
}
readings <- data.frame(date, measurement, interpolated)
# Import CSV
readings <- read.csv('../Data/readings.csv')
readings$date <- as.Date(readings$date, format = "%d/%m/%Y")
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
View(interpolate)
range(readings$measurement)
?range
range(readings$measurement)
readings$measurement
# Import CSV
readings <- read.csv('../Data/readings.csv')
readings$date <- as.Date(readings$date, format = "%d/%m/%Y")
readings$measurement
range(readings$measurement)
# Import CSV
readings <- read.csv('../Data/readings.csv')
readings$date <- as.Date(readings$date, format = "%d/%m/%Y")
readings <- interpolate(readings)
usage_statistics <- function(df, ppu){
# Take a df of readings along with the price per unit and return vital statistics
total_usage <- df$measurement
}
print(interpolate(readings))
return(total_usage)
usage_statistics <- function(df, ppu){
# Take a df of readings along with the price per unit and return vital statistics
total_usage <- df$measurement
return(total_usage)
}
source('~/Coding/BarnMeter/Code/BarnMeter.R')
# Take a df of readings along with the price per unit and return vital statistics
total_usage <- range(df$measurement)
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
source('~/Coding/BarnMeter/Code/BarnMeter.R')
